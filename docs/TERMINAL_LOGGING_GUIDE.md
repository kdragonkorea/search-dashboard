# 터미널 성능 로깅 가이드

## 📊 개요

키워드 검색 속도를 터미널에서 실시간으로 모니터링하는 로깅 시스템입니다.

**특징**:
- ✅ UI에 표시되지 않음 (화면 깔끔)
- ✅ 터미널 콘솔에만 출력
- ✅ 실시간 성능 모니터링
- ✅ 단계별 상세 시간 분석

---

## 🚀 사용 방법

### 1. 앱 실행

터미널에서 앱을 실행하세요:

```bash
cd "/Users/hana/Documents/99_coding/04_Search Trends  Dashboard"
./venv/bin/streamlit run app.py
```

또는:

```bash
python3 -m streamlit run app.py
```

### 2. 터미널 확인

앱 실행 후 터미널 창을 계속 보면서 키워드를 검색하세요.

---

## 📝 로그 출력 형식

### 키워드 검색 시 터미널 출력 예시

```
14:23:45 | INFO | ━━━ 키워드 검색 시작 ━━━
14:23:45 | INFO |   🟢 키워드 목록 생성 (Top 100): 0.089초
14:23:45 | INFO |   🟢 Selectbox 렌더링: 0.143초
14:23:45 | INFO |   🟢 데이터 필터링 (제주도): 0.038초
14:23:46 | INFO |   🟡 차트 렌더링 (전체): 0.452초
14:23:46 | INFO | ━━━ 키워드 검색 완료: 🟡 0.72초 ━━━

```

### 로그 구조

```
[시간] | [레벨] | [메시지]
```

- **시간**: HH:MM:SS 형식
- **레벨**: INFO (정보)
- **메시지**: 작업 또는 단계 정보

---

## 🎨 상태 이모지

| 이모지 | 시간 | 의미 |
|--------|------|------|
| 🟢 | < 0.3초 | 매우 빠름 - 최적 성능 |
| 🟡 | 0.3~1초 | 빠름 - 양호한 성능 |
| 🟠 | 1~2초 | 보통 - 개선 여지 있음 |
| 🔴 | > 2초 | 느림 - 최적화 필요 |

---

## 📊 로그 항목 설명

### 1. 키워드 목록 생성 (Top 100)

**의미**: 현재 기간의 인기 검색어 Top 100 추출
**목표 시간**: < 0.1초
**예시**:
```
🟢 키워드 목록 생성 (Top 100): 0.089초
```

### 2. Selectbox 렌더링

**의미**: Streamlit selectbox UI 컴포넌트 생성
**목표 시간**: < 0.15초
**예시**:
```
🟢 Selectbox 렌더링: 0.143초
```

### 3. 데이터 필터링

**의미**: 선택된 키워드로 데이터 필터링
**목표 시간**: < 0.05초
**예시**:
```
🟢 데이터 필터링 (제주도): 0.038초
```

### 4. 차트 렌더링 (전체)

**의미**: 메인 차트 + 파이 차트 4개 생성
**목표 시간**: < 0.5초
**예시**:
```
🟡 차트 렌더링 (전체): 0.452초
```

### 5. 전체 완료

**의미**: 키워드 검색 전체 소요 시간
**목표 시간**: < 1초
**예시**:
```
━━━ 키워드 검색 완료: 🟡 0.72초 ━━━
```

---

## 🔍 로그 해석

### 예시 1: 최적 성능

```
14:23:45 | INFO | ━━━ 키워드 검색 시작 ━━━
14:23:45 | INFO |   🟢 키워드 목록 생성 (Top 100): 0.082초
14:23:45 | INFO |   🟢 Selectbox 렌더링: 0.098초
14:23:45 | INFO |   🟢 데이터 필터링 (부산): 0.032초
14:23:45 | INFO |   🟢 차트 렌더링 (전체): 0.368초
14:23:46 | INFO | ━━━ 키워드 검색 완료: 🟢 0.58초 ━━━
```

**해석**: 
- ✅ 모든 단계가 목표 시간 이내
- ✅ 전체 소요 시간 0.58초 (매우 빠름)
- ✅ 최적 상태

### 예시 2: 차트 렌더링 병목

```
14:25:12 | INFO | ━━━ 키워드 검색 시작 ━━━
14:25:12 | INFO |   🟢 키워드 목록 생성 (Top 100): 0.095초
14:25:12 | INFO |   🟢 Selectbox 렌더링: 0.112초
14:25:12 | INFO |   🟢 데이터 필터링 (서울): 0.041초
14:25:13 | INFO |   🟠 차트 렌더링 (전체): 1.102초  ← 병목!
14:25:13 | INFO | ━━━ 키워드 검색 완료: 🟠 1.35초 ━━━
```

**해석**:
- ⚠️ 차트 렌더링이 1.1초 소요 (목표: 0.5초)
- ⚠️ 전체 소요 시간 1.35초
- 🔧 차트 렌더링 최적화 필요

**원인 가능성**:
1. 데이터 크기가 큼 (50만 행 이상)
2. 캐시 미스
3. 복잡한 차트

**해결 방안**:
1. 데이터 행 수 확인
2. "데이터 새로고침" 버튼 클릭
3. 브라우저 재시작

### 예시 3: 키워드 목록 생성 병목

```
14:27:34 | INFO | ━━━ 키워드 검색 시작 ━━━
14:27:35 | INFO |   🔴 키워드 목록 생성 (Top 100): 1.234초  ← 병목!
14:27:35 | INFO |   🟢 Selectbox 렌더링: 0.123초
14:27:35 | INFO |   🟢 데이터 필터링 (제주도): 0.045초
14:27:35 | INFO |   🟡 차트 렌더링 (전체): 0.448초
14:27:36 | INFO | ━━━ 키워드 검색 완료: 🔴 1.85초 ━━━
```

**해석**:
- 🔴 키워드 목록 생성이 1.2초 소요 (목표: 0.1초)
- ⚠️ 전체 소요 시간 1.85초
- 🔧 키워드 목록 생성 최적화 필요

**원인 가능성**:
1. `trend_df`가 매우 큼
2. value_counts() 연산 느림

**해결 방안**:
1. Top 100 → Top 50으로 줄이기
2. 데이터 크기 확인

---

## 💡 활용 시나리오

### 시나리오 1: 실시간 모니터링

**목적**: 키워드 검색 속도 체감

**방법**:
1. 터미널과 브라우저를 나란히 배치
2. 키워드 검색
3. 터미널에서 즉시 로그 확인

**예시**:
```
브라우저: "제주도" 선택
터미널:   ━━━ 키워드 검색 완료: 🟡 0.68초 ━━━

브라우저: "부산" 선택
터미널:   ━━━ 키워드 검색 완료: 🟡 0.72초 ━━━

브라우저: 막대형 → 선형 변경
터미널:   (로그 없음 - 0.5초 이하라서)
```

### 시나리오 2: 성능 비교

**목적**: 여러 키워드 속도 비교

**방법**:
1. 여러 키워드 순차 검색
2. 터미널 로그 스크롤하여 비교

**예시**:
```
14:23:45 | INFO | ━━━ 키워드 검색 완료: 🟡 0.68초 ━━━  (제주도)
14:24:12 | INFO | ━━━ 키워드 검색 완료: 🟡 0.72초 ━━━  (부산)
14:24:35 | INFO | ━━━ 키워드 검색 완료: 🟢 0.65초 ━━━  (서울)
```

**분석**: 서울이 가장 빠름 (0.65초)

### 시나리오 3: 병목 지점 찾기

**목적**: 느린 단계 식별

**방법**:
1. 느린 검색 발견 시
2. 해당 로그의 각 단계별 시간 확인
3. 가장 느린 단계 식별

**예시**:
```
14:25:12 | INFO |   🟢 키워드 목록 생성: 0.095초   ✅ 빠름
14:25:12 | INFO |   🟢 Selectbox 렌더링: 0.112초   ✅ 빠름
14:25:12 | INFO |   🟢 데이터 필터링: 0.041초      ✅ 빠름
14:25:13 | INFO |   🟠 차트 렌더링: 1.102초        ⚠️ 병목!
```

**결론**: 차트 렌더링 최적화 필요

---

## 🛠️ 터미널 로그 관리

### 로그 저장

터미널 출력을 파일로 저장:

```bash
./venv/bin/streamlit run app.py 2>&1 | tee performance.log
```

**결과**: `performance.log` 파일에 모든 로그 저장

### 로그 필터링

특정 키워드만 보기:

```bash
# macOS/Linux
./venv/bin/streamlit run app.py 2>&1 | grep "키워드 검색"

# 완료 로그만 보기
./venv/bin/streamlit run app.py 2>&1 | grep "완료"
```

### 로그 실시간 모니터링

```bash
# 파일에 저장하면서 동시에 터미널에도 표시
./venv/bin/streamlit run app.py 2>&1 | tee -a performance.log
```

---

## 📊 성능 기준

### 목표 시간

| 항목 | 목표 | 양호 | 개선 필요 |
|------|------|------|----------|
| 키워드 목록 생성 | < 0.1초 | < 0.2초 | > 0.2초 |
| Selectbox 렌더링 | < 0.15초 | < 0.25초 | > 0.25초 |
| 데이터 필터링 | < 0.05초 | < 0.1초 | > 0.1초 |
| 차트 렌더링 | < 0.5초 | < 0.8초 | > 0.8초 |
| **전체** | **< 0.7초** | **< 1.2초** | **> 1.2초** |

### 상태별 대응

#### 🟢 매우 빠름 (< 0.3초)
- 현재 상태 유지
- 추가 최적화 불필요

#### 🟡 빠름 (0.3~1초)
- 정상 범위
- 모니터링 지속

#### 🟠 보통 (1~2초)
- 원인 분석 필요
- 데이터 크기 확인
- 캐시 상태 확인

#### 🔴 느림 (> 2초)
- 즉시 최적화 필요
- 병목 지점 식별
- `PERFORMANCE_ROOT_CAUSE.md` 참고

---

## 🎯 장점

### 1. 비침습적
- UI에 표시되지 않음
- 사용자 경험에 영향 없음
- 화면 깔끔 유지

### 2. 실시간
- 즉시 성능 확인
- 단계별 상세 분석
- 병목 지점 즉시 파악

### 3. 간편함
- 터미널만 확인
- 별도 도구 불필요
- 앱 실행과 동시에 작동

### 4. 유연함
- 로그 저장 가능
- 필터링 가능
- 분석 도구와 연동 가능

---

## 🔧 문제 해결

### 로그가 보이지 않음

**원인**: 로깅 레벨 설정 문제

**확인**:
```python
# app.py 상단 확인
logging.basicConfig(level=logging.INFO, ...)
```

**해결**: 코드가 올바른지 확인

### 로그가 너무 많음

**해결**: 0.5초 이하 작업은 자동으로 제외됨

필요시 임계값 조정:
```python
if elapsed > 0.5:  # ← 이 값을 조정 (예: 1.0)
    perf_logger.log_step(self.name, elapsed)
```

### 로그 시간이 부정확함

**원인**: Streamlit 재실행 지연

**해결**: 
- 여러 번 측정 후 평균
- 첫 실행 제외하고 2~3회 평균

---

## 📝 예시 세션

### 완전한 키워드 검색 세션

```bash
$ ./venv/bin/streamlit run app.py

  You can now view your Streamlit app in your browser.
  Local URL: http://localhost:8501

14:23:12 | INFO | ━━━ 키워드 검색 시작 ━━━
14:23:12 | INFO |   🟢 키워드 목록 생성 (Top 100): 0.089초
14:23:12 | INFO |   🟢 Selectbox 렌더링: 0.143초
14:23:12 | INFO |   🟢 데이터 필터링 (제주도): 0.038초
14:23:12 | INFO |   🟡 차트 렌더링 (전체): 0.452초
14:23:13 | INFO | ━━━ 키워드 검색 완료: 🟡 0.72초 ━━━

14:23:45 | INFO | ━━━ 키워드 검색 시작 ━━━
14:23:45 | INFO |   🟢 키워드 목록 생성 (Top 100): 0.092초
14:23:45 | INFO |   🟢 Selectbox 렌더링: 0.125초
14:23:45 | INFO |   🟢 데이터 필터링 (부산): 0.043초
14:23:46 | INFO |   🟡 차트 렌더링 (전체): 0.468초
14:23:46 | INFO | ━━━ 키워드 검색 완료: 🟡 0.73초 ━━━

14:24:18 | INFO | ━━━ 키워드 검색 시작 ━━━
14:24:18 | INFO |   🟢 키워드 목록 생성 (Top 100): 0.095초
14:24:18 | INFO |   🟢 Selectbox 렌더링: 0.112초
14:24:18 | INFO |   🟢 데이터 필터링 (제주도): 0.041초
14:24:18 | INFO |   🟡 차트 렌더링 (전체): 0.389초
14:24:18 | INFO | ━━━ 키워드 검색 완료: 🟡 0.64초 ━━━
```

**분석**:
- 3회 검색 모두 1초 이내 완료
- 평균: 0.70초
- 제주도 재검색이 가장 빠름 (캐시 효과)

---

## 🎯 결론

### 터미널 로깅의 장점

✅ **깔끔한 UI**: 사용자 화면에 영향 없음
✅ **실시간 모니터링**: 즉시 성능 확인
✅ **상세 분석**: 단계별 시간 분해
✅ **개발자 친화적**: 터미널 환경에 익숙

### 활용 가이드

- **일상 사용**: 터미널을 옆에 두고 모니터링
- **디버깅**: 느린 작업 발견 시 로그 분석
- **최적화**: 병목 지점 식별 및 개선
- **검증**: 최적화 효과 정량적 측정

**이제 터미널에서 앱 성능을 실시간으로 모니터링할 수 있습니다!** 🎉

---

## 📞 참고

- 로그는 INFO 레벨로 출력
- 0.5초 이상 작업만 자동 로그
- Streamlit 내부 로그와 구분 가능
- 저장/필터링 자유롭게 활용

문의사항이나 개선 제안이 있으면 알려주세요!
